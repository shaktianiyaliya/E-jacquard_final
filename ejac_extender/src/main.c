/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 7.1.0   2018-01-30

The MIT License (MIT)
Copyright (c) 2009-2017 Atollic AB

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include "stm32f4xx.h"
#include "uart.h"
#include "flash.h"
#include "protocol.h"
#include "extender.h"
#include <string.h>
#include <stdlib.h>
#if (MERGE_IMAGE_TEST == 1)
#include "bmpImage.h"
#endif
#define MAXLINES 100


/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
void action_idle(void);
void action_status(void);
void action_load(void);
void action_load_handle(void);
void action_start(void);
void action_stop(void);
//void action_jump(void);
void action_image_config(void);
void action_image_info(void);
void action_hardware_config(void);
void action_test_pattern(void);
void action_img_detail_status(void);
void action_hw_detail_status(void);
void action_feed_data(void);
void single_border(void);
void Merge_border(void);

extern ejac_mode Mode;
volatile uint8_t LatchingDataFlag = 0, hrdwrSettingsDone = 0;

int main(void)
{
	uart_init();
	extender_init();
#if (MERGE_IMAGE_TEST == 1)
	test_image_init();
#endif
    action_flag = IDLE;
  	while(1)
	{
		switch(action_flag)
		{
			case STATUS: action_status();
				break;
			case LOAD: action_load_handle();
				break;
			case START: action_start();
				break;
			case STOP: action_stop();
				break;
			/*case JUMP: action_jump();
				break;*/
			case IMAGE_CONFIG: action_image_config();
				break;
			case HARDWARE_CONFIG: action_hardware_config();
				break;
			case IMAGE_INFO: action_image_info();
				break;
			case IMAGE_DETAIL_STATUS: action_img_detail_status();
				break;
			case HARDWARE_DETAIL_STATUS: action_hw_detail_status();
				break;
			case IDLE: action_idle();
				break;
			case BUSY: break;
			case TEST_PATTERN: action_test_pattern();
				break;
#if (MERGE_IMAGE_TEST == 1)
			case TEST_IMAGE_WEAVING:
				send_merge_image_data();
				break;
			default:
				break;
#endif
		}

		if((feed_next_data) && (Mode == RUNNING))
		{
			//action_feed_data();
			currline_response(SUCCES);
		}

		if(receive_input_data)
		{
			action_load();
		}

	}
}

void action_idle(void)
{
	if ((cmd_count == SIZE_CMD))
	{
		sel_action();
	}
}

void action_status(void)
{
	response(SUCCES);
}


int16_t find_existence_duplicate_fileID(uint8_t findFileId, uint8_t *duplicateFileIdPos)
{
	int16_t iter, duplicateFileIdPosCounter = 0;
	for(iter = findFileId; iter < config_data.ImageCount; iter++)
	{
		if(image_order.ImgOrder[findFileId - 1].FileID == image_order.ImgOrder[iter].FileID)
		{
			duplicateFileIdPos[duplicateFileIdPosCounter] = iter;
			duplicateFileIdPosCounter++;
		}

	}

	return duplicateFileIdPosCounter;
}

void action_load_handle(void)
{
	uint8_t fileIdPosArr[16];
	int16_t duplicateFileIdCount = 0, iter;

	if (cmd_count >= (sizeof(ejac_cmd_load_t)+SIZE_CMD))
	{
			memset(fileIdPosArr, 0, 16);
			memcpy(&load_cmd, (save_buffer + SIZE_CMD), sizeof(ejac_cmd_load_t));
			cmd_count = 0;
			/* buff_len is the total size of the current image being loaded and is used
			 * for comparison purpose as image data will be arriving in chunk format */
			buff_len = load_cmd.Width * load_cmd.Height;
			memset(save_buffer,0, PAGE_SIZE);
			file_id = load_cmd.FileId;
			if(load_cmd.FileId == 1)
			{
				flash_start_addr[0] = 0x08020000;
			}
			else
			{
				/* duplicateFileIdcount consists a valid count if same body
				 * is repeated as another image
				 * Duplicate count is used so as to not write the same image twice
				 * into the flash*/

				duplicateFileIdCount = find_existence_duplicate_fileID(file_id, fileIdPosArr);
				if(duplicateFileIdCount > 0)
				{
					for(iter = 0; iter < duplicateFileIdCount; iter++)
					{
						int16_t pos = fileIdPosArr[iter];
						flash_start_addr[pos] = (flash_end_addr[load_cmd.FileId - 2] + 2);
					}

				}
				flash_start_addr[load_cmd.FileId - 1] = (flash_end_addr[load_cmd.FileId - 2] + 2);

			}
			receive_input_data = 1;
			response(SUCCES);
			action_flag = BUSY;
	}
}


void action_load(void)
{
	if(load_count < buff_len)
	{
		if(cmd_count >= sizeof(uint32_t))
		{
			memcpy(&current_load_size, (uint8_t *)&save_buffer, sizeof(uint32_t));
			if((cmd_count >= (current_load_size + sizeof(uint32_t))) )
			{
				uint8_t flash_result;
				flash_result = flash_write(((uint8_t *)&save_buffer+4),current_load_size,(uint32_t)(flash_start_addr[file_id - 1]+(load_count)));
				if(flash_result == FLASH_PASS)
				{
					action_flag = LOAD;
					memset(&save_buffer,0,PAGE_SIZE);
					load_count += current_load_size;
					cmd_count = 0;
					current_load_size = 0;
					receive_input_data = 1;
					img_count++;
					response(SUCCES);
					action_flag = BUSY;
				}
				else if(FLASH_FAIL == flash_result)
				{
					response(FAIL_FLASH);
					action_flag = IDLE;
				}

			}
		}
	}
	else
	{
		ejac_image_extra_config_t temp_config;
		uint8_t fileIdPosArr[16];
		memset(&temp_config, 0,sizeof(ejac_image_extra_config_t));
		memset(fileIdPosArr, 0, 16);
		uint8_t *temp_ptr, flash_result;
		receive_input_data = 0;
		int16_t duplicateFileIdCount = 0, iter;
		if(file_id == 1)
		{
			flash_end_addr[file_id - 1] = flash_start_addr[0]+(load_count);
		}
		//TODO
		// check for the requirement of Duplicate File ID
		else
		{
			duplicateFileIdCount = find_existence_duplicate_fileID(file_id, fileIdPosArr);
			if(duplicateFileIdCount > 0)
			{
				for(iter = 0; iter < duplicateFileIdCount; iter++)
				{
					int16_t pos = fileIdPosArr[iter];
					flash_end_addr[pos] = flash_start_addr[file_id - 1]+(load_count);
				}

			}
			flash_end_addr[file_id - 1] = flash_start_addr[file_id - 1]+(load_count);
		}
		memset(save_buffer, 0, PAGE_SIZE);
		cmd_count = 0;
		buff_len = 0;
		memcpy(&temp_config, (uint32_t *)0x08010000, sizeof(ejac_cmd_image_config_t));
		if(1 == file_id)
		{
			memcpy(&temp_config, (uint32_t *)0x08010000, sizeof(ejac_cmd_image_config_t));
			temp_config.ExtraConfig1.FileID = load_cmd.FileId;
			temp_config.ExtraConfig1.Height = load_cmd.Height;
			temp_config.ExtraConfig1.Width = load_cmd.Width;
		//	temp_config.ExtraConfig1.Start = load_cmd.Start;
			temp_config.ExtraConfig1.BytesPerRow = load_cmd.Width;//(((load_cmd.Width+31)/32)*4);
			temp_config.ExtraConfig1.FlStartAdr = flash_start_addr[file_id - 1];
			temp_config.ExtraConfig1.FlEndAdr = flash_end_addr[file_id - 1];
		}
		else if(2 == file_id)
		{
			memcpy(&temp_config, (uint32_t *)0x08010000, sizeof(ejac_cmd_image_config_t)+sizeof(ejac_image_t));
			temp_config.ExtraConfig2.FileID = load_cmd.FileId;
			temp_config.ExtraConfig2.Height = load_cmd.Height;
			temp_config.ExtraConfig2.Width = load_cmd.Width;
	//		temp_config.ExtraConfig2.Start = load_cmd.Start;
	//		temp_config.ExtraConfig2.End = load_cmd.End;
			temp_config.ExtraConfig2.BytesPerRow = load_cmd.Width;//(((load_cmd.Width+31)/32)*4);
			temp_config.ExtraConfig2.FlStartAdr = flash_start_addr[file_id - 1];
			temp_config.ExtraConfig2.FlEndAdr = flash_end_addr[file_id - 1];
		}
		/*else if(3 == file_id)
		{
			memcpy(&temp_config, (uint32_t *)0x08010000, sizeof(ejac_cmd_image_config_t)+sizeof(ejac_image_t)+sizeof(ejac_image_t));
			temp_config.ExtraConfig3.FileID = load_cmd.FileId;
			temp_config.ExtraConfig3.Height = load_cmd.Height;
			temp_config.ExtraConfig3.Width = load_cmd.Width;
	//		temp_config.ExtraConfig3.Start = load_cmd.Start;
	//		temp_config.ExtraConfig3.End = load_cmd.End;
			temp_config.ExtraConfig3.BytesPerRow = load_cmd.Width;//(((load_cmd.Width+31)/32)*4);
			temp_config.ExtraConfig3.FlStartAdr = flash_start_addr[file_id - 1];
			temp_config.ExtraConfig3.FlEndAdr = flash_end_addr[file_id - 1];
		}
		else if(4 == file_id)
		{
			memcpy(&temp_config, (uint32_t *)0x08010000, sizeof(ejac_cmd_image_config_t)+sizeof(ejac_image_t)+sizeof(ejac_image_t)+sizeof(ejac_image_t));
			temp_config.ExtraConfig4.FileID = load_cmd.FileId;
			temp_config.ExtraConfig4.Height = load_cmd.Height;
			temp_config.ExtraConfig4.Width = load_cmd.Width;
	//		temp_config.ExtraConfig4.Start = load_cmd.Start;
	//		temp_config.ExtraConfig4.End = load_cmd.End;
			temp_config.ExtraConfig4.BytesPerRow = load_cmd.Width; //(((load_cmd.Width+31)/32)*4);
			temp_config.ExtraConfig4.FlStartAdr = flash_start_addr[file_id - 1];
			temp_config.ExtraConfig4.FlEndAdr = flash_end_addr[file_id - 1];
		}*/
		temp_ptr = (uint8_t *)&temp_config;
		flash_result = flash_sector_erase((uint32_t)CONFIG_ADDR);
		if (flash_result == FLASH_FAIL)
		{
			response(FAIL_FLASH);
			return;
		}
		flash_result = flash_write(temp_ptr, sizeof(ejac_image_extra_config_t), (uint32_t)0x08010000);
		memcpy(&config_data, (uint32_t *)0x08010000, (SIZE_CMD_IMG_CONFIG-SIZE_CMD));
		memcpy(&extra_config, (uint32_t *)0x08010000, sizeof(ejac_image_extra_config_t));
		if (flash_result == FLASH_FAIL)
		{
			response(FAIL_FLASH);
			return;
		}
		load_count = 0;
		action_flag = IDLE;
	}

}
void action_start(void)
{
	if(cmd_count >= (sizeof(ejac_cmd_start_t)+SIZE_CMD))
	{
		uint8_t act_count;
		memcpy(&start_cmd, (save_buffer + SIZE_CMD), sizeof(ejac_cmd_start_t));
		line_count1 = start_cmd.Line1;
		itr1 = start_cmd.Itr1;
		line_count2 = start_cmd.Line2;
		itr2 = start_cmd.Itr2;
		/*line_count3 = start_cmd.Line3;
		itr3 = start_cmd.Itr3;
		line_count4 = start_cmd.Line4;
		itr4 = start_cmd.Itr4;*/
		g_curr_line = start_cmd.GlobalCurr;
#if (MERGE_IMAGE_TEST == 1)
		action_flag = TEST_IMAGE_WEAVING;
#else
		if((flash_start_addr[0] == 0) || (hrdwrSettingsDone == 0))
		{
			memcpy(&config_data, (uint32_t *)0x08010000, (SIZE_CMD_IMG_CONFIG-SIZE_CMD));
			memcpy(&extra_config, (uint32_t *)0x08010000, sizeof(ejac_image_extra_config_t));
			memcpy(&config_hw, (uint32_t *)0x0800C000, (SIZE_CMD_HW_CONFIG-SIZE_CMD));
			memcpy(&image_order, (uint32_t *)0x080E0000, sizeof(ejac_cmd_image_order_t));

			if(config_hw.Sensor1.Sensor_Status == EJAC_ENABLE)
			{
				if(config_hw.Sensor1.Sensor_Type == NPN)
				{
					sensor1_npn_init();
				}
				else if(config_hw.Sensor1.Sensor_Type == PNP)
				{
					sensor1_pnp_init();
				}
			}
			else
			{
				//TODO:
			}

			if(config_hw.Sensor2.Sensor_Status == EJAC_ENABLE)
			{
				if(config_hw.Sensor2.Sensor_Type == NPN)
				{
					sensor2_npn_init();
				}
				else if(config_hw.Sensor2.Sensor_Type == PNP)
				{
					sensor2_pnp_init();
				}
			}
			else
			{
				//TODO:
			}
			/*if(config_hw.Sensor3.Sensor_Status == EJAC_ENABLE)
			{
				if(config_hw.Sensor3.Sensor_Type == NPN)
				{
					sensor3_npn_init();
				}
				else if(config_hw.Sensor3.Sensor_Type == PNP)
				{
					sensor3_pnp_init();
				}
			}*/

			for(act_count = 0; act_count < config_hw.MaxRows; act_count++)
			{
				if(config_hw.ActiveRows[act_count])
				{
					act_rows++;
				}
			}
			for(act_count = 0; act_count < config_hw.MaxColumns; act_count++)
			{
				if(config_hw.ActiveColumns[act_count])
				{
					act_cols++;
				}
			}
			hrdwrSettingsDone = 1;
		}
		NVIC_EnableIRQ(EXTI0_IRQn);
		NVIC_EnableIRQ(EXTI1_IRQn);
		/*MJN:Check and comment out the checking part*/
#if 0 // MJN
		if ((extra_config.ExtraConfig1.BytesPerRow + extra_config.ExtraConfig2.BytesPerRow + extra_config.ExtraConfig3.BytesPerRow + extra_config.ExtraConfig4.BytesPerRow ) > (config_hw.MaxRows * config_hw.MaxColumns))
		{
			response(IMG_WIDTH_ERROR);
			cmd_count = 0;
			action_flag = IDLE;
			return;
		}
#endif //MJN
#if 0 // MJN
		if ((extra_config.ExtraConfig1.BytesPerRow + extra_config.ExtraConfig2.BytesPerRow + extra_config.ExtraConfig3.BytesPerRow + extra_config.ExtraConfig4.BytesPerRow ) > (act_cols * act_rows))
		{
			response(IMG_WIDTH_ERROR);
			cmd_count = 0;
			action_flag = IDLE;
			return;
		}
#endif //MJN

		if(config_data.ImageCount == 1)
		{
			line_count2 = -1; line_count3 = -1; line_count4 = -1;
		}
		else if(config_data.ImageCount == 2)
		{
			line_count3 = -1; line_count4 = -1;
		}
		else if(config_data.ImageCount == 3)
		{
			line_count4 = -1;
		}
		response(SUCCES);
		uint32_t i,j;
		for(i =0; i<100;i++)
		{
			for(j =0; j<10000;j++);

		}

		if((0 == border_count) || (0 == body_count))
		{
			body_count = 0;
			border_count = 0;
			for(act_count = 0; act_count < 	10; act_count++)
			{
				if(image_order.ImgOrder[act_count].BBType == BORDER)
				{
					border_count++;
				}
				else if(image_order.ImgOrder[act_count].BBType == BODY)
				{
					body_count++;
				}
			}
		}
		//feed_next_data = 1;
		LatchingDataFlag = 0x10;
		action_feed_data();
	//	EXTI_ClearITPendingBit(EXTI_Line0);

//		EXTI_ClearITPendingBit(EXTI_Line1);
		cmd_count = 0;
		action_flag = IDLE;
#endif

	}
}

void action_stop(void)
{
	feed_next_data = 0;
	Mode = SETTING;
	EXTI_ClearITPendingBit(EXTI_Line0);
	NVIC_DisableIRQ(EXTI0_IRQn);
	EXTI_ClearITPendingBit(EXTI_Line1);
	NVIC_DisableIRQ(EXTI1_IRQn);
	response(SUCCES);
	LatchingDataFlag = 0;
	action_flag = IDLE;
}

/*void action_jump(void)
{
	action_flag = START;
	response(SUCCES);
}*/

void action_image_config(void)
{
	if(cmd_count == SIZE_CMD_IMG_CONFIG)
	{
		ejac_status_type status;
		uint8_t  * config_ptr, flash_result;
		memcpy(&config_data, (save_buffer+SIZE_CMD), (SIZE_CMD_IMG_CONFIG-SIZE_CMD));
		config_ptr = (uint8_t *)&config_data;
		FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGPERR | FLASH_FLAG_WRPERR);
		flash_result = flash_sector_erase((uint32_t)CONFIG_ADDR);
		if (flash_result == FLASH_FAIL)
		{
			response(FAIL_FLASH);
			return;
		}
		flash_result = flash_write(config_ptr, (SIZE_CMD_IMG_CONFIG-SIZE_CMD), (uint32_t)0x08010000);
		if (flash_result == FLASH_FAIL)
		{
			response(FAIL_FLASH);
			return;
		}
		if(config_data.ImageCount == 1)
		{
			line_count2 = -1; line_count3 = -1; line_count4 = -1;
		}
		else if(config_data.ImageCount == 2)
		{
			line_count3 = -1; line_count4 = -1;
		}
		else if(config_data.ImageCount == 3)
		{
			line_count4 = -1;
		}
		g_curr_line = 0;
		status = erase_flash();
		if(status == SUCCES)
		{
			response(SUCCES);
		}
		else if((status == FAIL_FLASH) || (status == FAIL))
		{
			response(FAIL_FLASH);
		}
	}
}

void action_hardware_config(void)
{
	if(cmd_count == SIZE_CMD_HW_CONFIG)
	{
		disable_sensors();
		uint8_t  * config_ptr, flash_result;
		memcpy(&config_hw, (save_buffer+SIZE_CMD), (SIZE_CMD_HW_CONFIG-SIZE_CMD));
		config_ptr = (uint8_t *)&config_hw;
		FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGPERR | FLASH_FLAG_WRPERR);
		flash_result = flash_sector_erase((uint32_t)HW_ADDR);
		if (flash_result == FLASH_FAIL)
		{
			response(FAIL_FLASH);
			return;
		}
		flash_result = flash_write(config_ptr, (SIZE_CMD_HW_CONFIG-SIZE_CMD), (uint32_t)0x0800C000);
		if (flash_result == FLASH_FAIL)
		{
			response(FAIL_FLASH);
			return;
		}

		if(config_hw.Sensor1.Sensor_Status == EJAC_ENABLE)
		{
			if(config_hw.Sensor1.Sensor_Type == NPN)
			{
				sensor1_npn_init();
			}
			else if(config_hw.Sensor1.Sensor_Type == PNP)
			{
				sensor1_pnp_init();
			}
		}
		else
		{
			//TODO:
			EXTI_ClearITPendingBit(EXTI_Line0);
			NVIC_DisableIRQ(EXTI0_IRQn);
		}

		if(config_hw.Sensor2.Sensor_Status == EJAC_ENABLE)
		{
			if(config_hw.Sensor2.Sensor_Type == NPN)
			{
				sensor2_npn_init();
			}
			else if(config_hw.Sensor2.Sensor_Type == PNP)
			{
				sensor2_pnp_init();
			}
		}
		else
		{
			//TODO:
			EXTI_ClearITPendingBit(EXTI_Line1);
			NVIC_DisableIRQ(EXTI1_IRQn);
		}

#if 0
		if(config_hw.Sensor3.Sensor_Status == EJAC_ENABLE)
		{
			if(config_hw.Sensor3.Sensor_Type == NPN)
			{
				sensor3_npn_init();
			}
			else if(config_hw.Sensor3.Sensor_Type == PNP)
			{
				sensor3_pnp_init();
			}
		}
#endif
		act_cols = 0;
		act_rows = 0;

		uint8_t act_count;
		for(act_count = 0; act_count < config_hw.MaxRows; act_count++)
		{
			if(config_hw.ActiveRows[act_count])
			{
				act_rows++;
			}
		}
		for(act_count = 0; act_count < config_hw.MaxColumns; act_count++)
		{
			if(config_hw.ActiveColumns[act_count])
			{
				act_cols++;
			}
		}

		response(SUCCES);
		hrdwrSettingsDone = 1;
	}
}

void action_image_info(void)
{
	if(cmd_count == sizeof(ejac_cmd_image_order_t))
	{
		uint8_t  *config_ptr, flash_result;
		memcpy(&image_order, (save_buffer+SIZE_CMD), sizeof(ejac_cmd_image_order_t));
		config_ptr = (uint8_t *)&image_order;
		FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGPERR | FLASH_FLAG_WRPERR);
		flash_result = flash_sector_erase((uint32_t)IMAGE_ORDER);
		if (flash_result == FLASH_FAIL)
		{
			response(FAIL_FLASH);
			return;
		}

		flash_result = flash_write(config_ptr, sizeof(ejac_cmd_image_order_t), (uint32_t)0x080E0000);
		if (flash_result == FLASH_FAIL)
		{
			response(FAIL_FLASH);
			return;
		}

		uint8_t act_count;
		for(act_count = 0; act_count < 	10; act_count++)
		{
			if(image_order.ImgOrder[act_count].BBType == BORDER)
			{
				border_count++;
			}
			else if(image_order.ImgOrder[act_count].BBType == BODY)
			{
				body_count++;
			}
		}

		response(SUCCES);
	}
}

void action_img_detail_status(void)
{
	response(SUCCES);
}

void action_hw_detail_status(void)
{
	response(SUCCES);
}


void jari_complement(uint8_t *arr, int16_t size)
{
	int16_t iter = 0;

	for (iter = 0;iter < size; iter++)
	{
		arr[iter] = ~(arr[iter]);
	}
}


void pattern_test(void)
{
	if( (act_cols == 0) || (act_rows == 0))
	{
		act_cols = config_hw.MaxColumns;
		act_rows = config_hw.MaxRows;
	}

	uint8_t addr, cl_cards,idx_count = 0,cl_count = 0, idx;
	uint8_t data_port,clk_port;
    uint8_t data_pin,clk_pin;

    if((test_pattern.testType == 'j') && (g_curr_line % 2))
	{
		jari_complement(test_pattern.Pattern, 120);
	}
	else if((test_pattern.testType == 'j') && (g_curr_line != 0))
	{
		jari_complement(test_pattern.Pattern, 120);
	}

    /*Enabling demux which controls FRC Port Selection*/
    MUX_LOW;
	if(g_curr_line < test_pattern.Rep)
	{
		//MJN Where we taking pattern from testapplication
		//memcpy(cl_line, test_pattern.Pattern, (act_cols * act_rows));
		GPIO_ResetBits(GPIOA, OE_PIN);

		for (addr = 0; addr < config_hw.MaxColumns; addr++)
		{
			/*
			 * Accessing clock port&pin and data port& pin for each FRC slot since we are using
			 * we are using separate lines for clock and data for each FRC slot
			*/
			data_port = data_pins[addr][1];
			clk_port = clock_pins[addr][1];
			data_pin = (uint8_t)atoi(&data_pins[addr][2]);
			clk_pin = (uint8_t)atoi(&clock_pins[addr][2]);

			if(config_hw.ActiveColumns[config_data.LogicColumns[addr]])
			{
					latch_addr_byte(config_data.LogicColumns[addr]);
					GPIO_SetBits(GPIOA, OE_PIN);
					cl_count = 11;

					for (cl_cards = 0; cl_cards < config_hw.MaxRows; cl_cards++)
					{
						if(config_hw.ActiveRows[cl_cards])
						{
									//idx = (idx_count * config_hw.MaxRows) + cl_cards;
							idx = (idx_count * act_rows) + cl_count;
							//latch_data_byte(test_pattern.Pattern[idx]);
							latch_data_byte(test_pattern.Pattern[idx],data_port,data_pin,clk_port,clk_pin);
						}
						else
						{
							latch_data_byte(0x00, data_port,data_pin,clk_port,clk_pin);
						}
						cl_count--;
					}
					idx_count++;
					GPIO_ResetBits(GPIOA, OE_PIN);
			}
			else
			{
					latch_addr_byte(config_data.LogicColumns[addr]);
					GPIO_SetBits(GPIOA, OE_PIN);
					for (cl_cards = 0; cl_cards < config_hw.MaxRows; cl_cards++)
					{
						latch_data_byte(0x00, data_port,data_pin,clk_port,clk_pin);
					}
					GPIO_ResetBits(GPIOA, OE_PIN);
			}
		}
		g_curr_line++;
	}
	else
	{
		GPIO_ResetBits(GPIOA, OE_PIN);

		for (addr = 0; addr < config_hw.MaxColumns; addr++)
		{
				latch_addr_byte(config_data.LogicColumns[addr]);
				GPIO_SetBits(GPIOA, OE_PIN);
				cl_count = 0;
				data_port = data_pins[addr][1];
				clk_port = clock_pins[addr][1];
				data_pin = (uint8_t)atoi(&data_pins[addr][2]);
				clk_pin = (uint8_t)atoi(&clock_pins[addr][2]);

				for (cl_cards = 0; cl_cards < config_hw.MaxRows; cl_cards++)
				{
						latch_data_byte(0x00, data_port,data_pin,clk_port,clk_pin);
						cl_count++;
				}
				GPIO_ResetBits(GPIOA, OE_PIN);
		}
		g_curr_line = 0;
		action_flag = IDLE;
		LatchingDataFlag = 0;
	}
	MUX_HIGH;
}




void action_feed_data(void)
{
/* START - Changes done on 19-05-2018*/


	if(LatchingDataFlag == 0x01)
	{
		pattern_test();
	}
    else if(LatchingDataFlag == 0x10)
	{
    	Merge_border();
#if 0 //MJN
		switch(border_count)
		{
			case 1: single_border(); break;
			default: break;
		}
#endif
	}


/* END - Changes done on 19-05-2018*/
	//uint8_t addr, cl_cards, idx, cl_line[config_hw.MaxRows * config_hw.MaxColumns];
	//memset(&cl_line[0], 0, (config_hw.MaxRows * config_hw.MaxColumns));
#if 0
	uint8_t addr, cl_cards,idx_count = 0,cl_count = 0, idx, cl_line[act_cols * act_rows];
	memset(&cl_line[0], 0, (act_cols * act_rows));
	action_flag = START;
	if(config_data.ModeType == SINGLE)
	{
		    memcpy(&cl_line[0],(uint32_t *)(extra_config.ExtraConfig1.FlStartAdr +(line_count1*extra_config.ExtraConfig1.BytesPerRow)), extra_config.ExtraConfig1.BytesPerRow);
			//memset(&cl_line,0x01, extra_config.ExtraConfig1.BytesPerRow);
			line_count1++;
	}
	else
	{
		if(config_data.ModeType == CONCATENATE)
		{
			switch(config_data.ImageCount)
			{
				case 2:
				if((extra_config.ExtraConfig2.Start == 0) && (extra_config.ExtraConfig2.End == 0))
				{
					memcpy(&cl_line[0],(uint32_t *)(extra_config.ExtraConfig1.FlStartAdr +(line_count1*extra_config.ExtraConfig1.BytesPerRow)), extra_config.ExtraConfig1.BytesPerRow);
					memcpy(&cl_line[extra_config.ExtraConfig1.BytesPerRow],(uint32_t *)(extra_config.ExtraConfig2.FlStartAdr +(line_count2*extra_config.ExtraConfig2.BytesPerRow)), extra_config.ExtraConfig2.BytesPerRow);
					line_count1++; line_count2++;
				}
				else if(((extra_config.ExtraConfig2.Start == 0) && (g_curr_line < extra_config.ExtraConfig2.End)) || ((extra_config.ExtraConfig2.Start != 0) && (g_curr_line >= extra_config.ExtraConfig2.Start)))
				{
					memcpy(&cl_line[0],(uint32_t *)(extra_config.ExtraConfig1.FlStartAdr +(line_count1*extra_config.ExtraConfig1.BytesPerRow)), extra_config.ExtraConfig1.BytesPerRow);
					memcpy(&cl_line[extra_config.ExtraConfig1.BytesPerRow],(uint32_t *)(extra_config.ExtraConfig2.FlStartAdr +(line_count2*extra_config.ExtraConfig2.BytesPerRow)), extra_config.ExtraConfig2.BytesPerRow);
					line_count1++; line_count2++;
				}
				else if((g_curr_line < extra_config.ExtraConfig2.Start) || (g_curr_line >= extra_config.ExtraConfig2.End))
				{
					memcpy(&cl_line[0],(uint32_t *)(extra_config.ExtraConfig1.FlStartAdr +(line_count1*extra_config.ExtraConfig1.BytesPerRow)), extra_config.ExtraConfig1.BytesPerRow);
					line_count1++;
				}
					break;

				case 3:
					memcpy(&cl_line[0],(uint32_t *)(extra_config.ExtraConfig1.FlStartAdr +(line_count1*extra_config.ExtraConfig1.BytesPerRow)), extra_config.ExtraConfig1.BytesPerRow);
					line_count1++;
				if ((g_curr_line >= extra_config.ExtraConfig2.Start) && (g_curr_line <= extra_config.ExtraConfig2.End))
				{
					memcpy(&cl_line[extra_config.ExtraConfig1.BytesPerRow],(uint32_t *)(extra_config.ExtraConfig2.FlStartAdr +(line_count2*extra_config.ExtraConfig2.BytesPerRow)), extra_config.ExtraConfig2.BytesPerRow );
					line_count2++;
				}
				else if((g_curr_line >= extra_config.ExtraConfig3.Start) && (g_curr_line <= extra_config.ExtraConfig3.End))
				{
					memcpy(&cl_line[extra_config.ExtraConfig1.BytesPerRow+extra_config.ExtraConfig2.BytesPerRow],(uint32_t *)(extra_config.ExtraConfig3.FlStartAdr +(line_count3*extra_config.ExtraConfig3.BytesPerRow)), extra_config.ExtraConfig3.BytesPerRow );
					line_count3++;
				}
					break;
				case 4:
					break;
				default: break;
			}
		}
		else if(config_data.ModeType == MERGE)
		{
			//TODO:
		}
	}

#if 0
	if((config_data.ImageCount == 1) && (config_data.ModeType == SINGLE))
	{
		memcpy(&cl_line[0],(uint32_t *)(extra_config.ExtraConfig1.FlStartAdr +(line_count1*extra_config.ExtraConfig1.BytesPerRow)), extra_config.ExtraConfig1.BytesPerRow);
		line_count1++;
	}
	else if((config_data.ImageCount == 2) && (config_data.ModeType == CONCATENATE))
	{
		memcpy(&cl_line[0],(uint32_t *)(extra_config.ExtraConfig1.FlStartAdr +(line_count1*extra_config.ExtraConfig1.BytesPerRow)), extra_config.ExtraConfig1.BytesPerRow);
		memcpy(&cl_line[extra_config.ExtraConfig1.BytesPerRow],(uint32_t *)(extra_config.ExtraConfig2.FlStartAdr +(line_count2*extra_config.ExtraConfig2.BytesPerRow)), extra_config.ExtraConfig2.BytesPerRow );
		line_count1++; line_count2++;
	}
	else if((config_data.ImageCount == 3) && (config_data.ModeType == CONCATENATE))
	{
		memcpy(&cl_line[0],(uint32_t *)(extra_config.ExtraConfig1.FlStartAdr +(line_count1*extra_config.ExtraConfig1.BytesPerRow)), extra_config.ExtraConfig1.BytesPerRow);
		memcpy(&cl_line[extra_config.ExtraConfig1.BytesPerRow],(uint32_t *)(extra_config.ExtraConfig2.FlStartAdr +(line_count2*extra_config.ExtraConfig2.BytesPerRow)), extra_config.ExtraConfig2.BytesPerRow );
		memcpy(&cl_line[extra_config.ExtraConfig1.BytesPerRow+extra_config.ExtraConfig2.BytesPerRow],(uint32_t *)(extra_config.ExtraConfig3.FlStartAdr +(line_count3*extra_config.ExtraConfig3.BytesPerRow)), extra_config.ExtraConfig3.BytesPerRow );
		line_count1++; line_count2++; line_count3++;
	}
	else if((config_data.ImageCount == 4) && (config_data.ModeType == CONCATENATE))
	{
		memcpy(&cl_line[0],(uint32_t *)(extra_config.ExtraConfig1.FlStartAdr +(line_count1*extra_config.ExtraConfig1.BytesPerRow)), extra_config.ExtraConfig1.BytesPerRow);
		memcpy(&cl_line[extra_config.ExtraConfig1.BytesPerRow],(uint32_t *)(extra_config.ExtraConfig2.FlStartAdr +(line_count2*extra_config.ExtraConfig2.BytesPerRow)), extra_config.ExtraConfig2.BytesPerRow );
		memcpy(&cl_line[extra_config.ExtraConfig1.BytesPerRow+extra_config.ExtraConfig2.BytesPerRow],(uint32_t *)(extra_config.ExtraConfig3.FlStartAdr +(line_count3*extra_config.ExtraConfig3.BytesPerRow)), extra_config.ExtraConfig3.BytesPerRow );
		memcpy(&cl_line[extra_config.ExtraConfig1.BytesPerRow+extra_config.ExtraConfig2.BytesPerRow+extra_config.ExtraConfig3.BytesPerRow], (uint32_t *)(extra_config.ExtraConfig4.FlEndAdr + (line_count4*extra_config.ExtraConfig4.BytesPerRow)), extra_config.ExtraConfig4.BytesPerRow);
		line_count1++; line_count2++; line_count3++; line_count4++;
	}
	else if ((config_data.ModeType == MERGE))
	{
		//TODO:
	}
	else
	{
		response(FAIL);
	}
#endif

	if(line_count1 == extra_config.ExtraConfig1.Height)
	{
		line_count1 = 0;
		itr1++;
	}
	if(line_count2 == extra_config.ExtraConfig2.Height)
	{
		line_count2 = 0;
		itr2++;
	}
	if(line_count3 == extra_config.ExtraConfig3.Height)
	{
		line_count3 = 0;
		itr3++;
	}
	if(line_count4 == extra_config.ExtraConfig4.Height)
	{
		line_count4 = 0;
		itr4++;
	}
	//GPIO_ResetBits(GPIOB, CL_OE_PIN);
	GPIO_ResetBits(GPIOA, OE_PIN);

	for (addr = 0; addr < config_hw.MaxColumns; addr++)
	{
		if(config_hw.ActiveColumns[config_data.LogicColumns[addr]])
		{
			latch_addr_byte(config_data.LogicColumns[addr]);
			GPIO_SetBits(GPIOA, OE_PIN);
			cl_count = 0;
			for (cl_cards = 0; cl_cards < config_hw.MaxRows; cl_cards++)
			{
				if(config_hw.ActiveRows[cl_cards])
				{
					//idx = (idx_count * config_hw.MaxRows) + cl_cards;
					idx = (idx_count * act_rows) + cl_count;
					latch_data_byte(cl_line[idx]);
				}
				else
				{
					latch_data_byte(0x00);
				}
				cl_count++;
			}
			idx_count++;
			GPIO_ResetBits(GPIOA, OE_PIN);
		}
		else
		{
			latch_addr_byte(config_data.LogicColumns[addr]);
			GPIO_SetBits(GPIOA, OE_PIN);
			for (cl_cards = 0; cl_cards < config_hw.MaxRows; cl_cards++)
			{
				latch_data_byte(0x00);
			}
			GPIO_ResetBits(GPIOA, OE_PIN);
		}

	}
	feed_next_data = 0;
	g_curr_line++;
	currline_response(SUCCES);
	action_flag = IDLE;
#endif
}

unsigned int reverseBits(unsigned char num)
{
#define  NO_OF_BITS 8
   unsigned char reverse_num = 0;
   int i;
   for (i = 0; i < NO_OF_BITS; i++)
   {
       if((num & (1 << i)))
          reverse_num |= 1 << ((NO_OF_BITS - 1) - i);
  }
   return reverse_num;
}

void ReverseByte(unsigned char *Bytes, unsigned int no_of_bytes)
{
       unsigned int i = 0;
       for (i=0; i< no_of_bytes; i++)
               Bytes[i] = reverseBits(Bytes[i]);
       return;
}
void vert_distribution(uint8_t * pixel_buffer, uint32_t BytesPerRow)
{
    //uint8_t i=0,j,k,l,m=0, temp;
    uint8_t i = 0, no_of_rows = 12;//Each set will have 12 Modules
    uint8_t no_of_cols = 10;
    //uint8_t result[no_of_rows][no_of_cols];
    uint8_t myresult[BytesPerRow]; //each row size of the image

    //printf(" BytesPerRow = %d\n", BytesPerRow);
    //MJN
    /*for(l=0; l<no_of_rows; l++)
        for(j=0; j<no_of_cols; j++)
            result[l][j] = 0;*/


        int column=0, modular=0,bitcount=0, bit,bytecount=0, bitfetch=0, shift=0, fetchindex=0;
        //column
        for(column=0; column < no_of_cols && i < BytesPerRow; column++) {
        //increment index after 8 bits, which indicates next modular
          for(modular = 0; modular < no_of_rows ; modular++) { //nothing but number of rows
                //fetch bit after every 12th bit
                bit=7;
		myresult[i]=0;
                for(bitcount = modular+(column* (no_of_rows*8)); bitcount < (no_of_rows*no_of_cols*8) && bit >= 0; bitcount+=no_of_rows) { //total bits is number of cols * number of rows * 8 (number of bits)
                        bytecount = bitcount/8;
                        bitfetch = 7-(bitcount%8);
                        fetchindex = (1 << bitfetch);
            if((bit-bitfetch) > 0) {
            	shift = bit-bitfetch;
			 myresult[i] = myresult[i] | ((pixel_buffer[bytecount] & fetchindex) << shift);
			}
			// else if((bit-bitfetch) == 0){
			//  myresult[i] = myresult[i] | ((pixel_buffer[bytecount] && (1 << bitfetch)));
			//  printf("((pixel_buffer[%d] && (1 << %d))) : %x", bytecount, bitfetch, ((pixel_buffer[bytecount] && (1 << bitfetch)) ));
			// }
			else {
				shift = bitfetch-bit;
			     myresult[i] = myresult[i] | ((pixel_buffer[bytecount] & fetchindex) >> shift);
			}
            //printf("=> Column: %d, Modular: %d, bit: %d, bitcount: %d, bytecount: %d, bytevalue: %x, bitfetch: %d, myresult[%d]:%x \n", column, modular, bit, bitcount, bytecount, pixel_buffer[bytecount],  bitfetch, i, myresult[i]);

				bit--;
                }
                	i++;
          }
        }


#if 0 // JN
    for(j=0;j<no_of_cols;j++)
        ReverseByte(&(result[0][j]), no_of_rows);

#endif

    for(i=0;i<BytesPerRow;i++)
    {
        *(pixel_buffer+i) = myresult[i];
    }

}


#if 0
//MJN
void vert_distribution(uint8_t * pixel_buffer, uint32_t BytesPerRow)
{
	uint8_t i=0,j,k,l,m=0,count=0, temp;
	uint8_t no_of_rows = 12;
	uint8_t no_of_cols = 10;
	uint8_t result[no_of_rows][no_of_cols];

    //MJN
    for(l=0; l<no_of_rows; l++)
        for(j=0; j<no_of_cols; j++)
            result[l][j] = 0;

    for(j=0; j<no_of_cols; j++)
    {
        for(k=0; k < 8; k++)
        {
            if (i < BytesPerRow)
            {
                for(l=0; l<no_of_rows; l++)
                {
                    if(m >= k)
                    {
                        temp = (*(pixel_buffer + i) & MASK(m)) >> (m-k);
                    }
                    else
                    {
                        temp = (*(pixel_buffer + i) & MASK(m)) << (k-m);
                    }
                    result[l][j] |= temp;
                    m++;
                    if((m == 8))
                    {
                        i++;
                        m = 0;
                    }
                }
            }
        }

    }

#if 0 // JN
    for(j=0;j<no_of_cols;j++)
        ReverseByte(&(result[0][j]), no_of_rows);

#endif
    //	while(count <BytesPerRow)
    //	{
    for(j=0;j<no_of_cols;j++)
    {
        for(i=0;i<no_of_rows;i++)
        {
            *(pixel_buffer+count) = result[i][j];
            count++;
        }

    }
    //	 }
}
#endif

void Merge_border(void)
{
	uint32_t activeRowSize = act_cols * act_rows;
	int8_t addr;
	uint8_t cl_cards;
	uint8_t idx_count = 0,cl_count = 0, idx;
	uint8_t data_port,clk_port;
	uint8_t data_pin,clk_pin;
	uint8_t cl_line[256] = {0};
	uint8_t borderLine[256] = {0};
	uint8_t bodyLine[256] = {0};
	uint32_t i;

	//Testing
	memset(&cl_line[0], 0, 256);
	memset(&borderLine[0], 0, 256);
	memset(&bodyLine[0], 0, 256);

	if(line_count1 >= extra_config.ExtraConfig1.Height)
	{
		line_count1 = 0;
		itr1++;
	}
	if(line_count2 >= extra_config.ExtraConfig2.Height)
	{
		line_count2 = 0;
		itr2++;
	}

	//action_flag = START;
	if(image_order.ImgOrder[0].BBType == BORDER)
	{
		memcpy(&borderLine[0],(uint32_t *)(extra_config.ExtraConfig1.FlStartAdr +(line_count1*extra_config.ExtraConfig1.BytesPerRow)), extra_config.ExtraConfig1.BytesPerRow);
		line_count1++;
	}

	 if(image_order.ImgOrder[1].BBType == BODY)
	{
		memcpy(&bodyLine[0],(uint32_t *)(extra_config.ExtraConfig2.FlStartAdr +(line_count2*extra_config.ExtraConfig2.BytesPerRow)), extra_config.ExtraConfig2.BytesPerRow);
		line_count2++;
	}

	 activeRowSize = 120;

	if( (extra_config.ExtraConfig2.BytesPerRow > 0) && (bodyLine[extra_config.ExtraConfig2.BytesPerRow-1] & 0xff) != 0)
	{
		for (i =0 ; i<activeRowSize; i++)
		{
			cl_line[i] = (bodyLine[i] & borderLine[i]);
		}
	}
	else
	{
		for (i = 0 ; i<activeRowSize; i++)
		{
			cl_line[i] = borderLine[i];
		}
	}
	vert_distribution(cl_line, 120); //MJN

	GPIO_ResetBits(GPIOA, OE_PIN);

	/*Enabling demux which controls FRC Port Selection*/
	MUX_LOW;

	for (addr = 0; addr < config_hw.MaxColumns; addr++)
	{
		/*
		 * Accessing clock port&pin and data port& pin for each FRC slot since we are using
		 * we are using separate lines for clock and data for each FRC slot
		*/
		data_port = data_pins[addr][1];
		clk_port = clock_pins[addr][1];
		data_pin = (uint8_t)atoi(&data_pins[addr][2]);
		clk_pin = (uint8_t)atoi(&clock_pins[addr][2]);

		if(config_hw.ActiveColumns[config_data.LogicColumns[addr]])
		{
			latch_addr_byte(config_data.LogicColumns[addr]);
			//latch_addr_byte(addr);
			GPIO_SetBits(GPIOA, OE_PIN);
			cl_count = 11;

			for (cl_cards = 0; cl_cards < config_hw.MaxRows; cl_cards++)
			{
				if(config_hw.ActiveRows[cl_cards])
				{
					//idx = (idx_count * config_hw.MaxRows) + cl_cards;
					idx = (idx_count * act_rows) + cl_count;
					latch_data_byte(cl_line[idx], data_port,data_pin,clk_port,clk_pin);
					//latch_data_byte(reverseBits(cl_line[idx]));
				}
				else
				{
					latch_data_byte(0x00, data_port,data_pin,clk_port,clk_pin);
				}
				cl_count--;
			}
			idx_count++;
			GPIO_ResetBits(GPIOA, OE_PIN);
		}
		else
		{
			latch_addr_byte(config_data.LogicColumns[addr]);
			GPIO_SetBits(GPIOA, OE_PIN);
			for (cl_cards = 0; cl_cards < config_hw.MaxRows; cl_cards++)
			{
				latch_data_byte(0x00, data_port,data_pin,clk_port,clk_pin);
			}
			GPIO_ResetBits(GPIOA, OE_PIN);
		}

	}
	g_curr_line++;
	MUX_HIGH;
	action_flag = IDLE;
}

#if 0
void single_border(void)
{
	uint8_t addr, cl_cards,idx_count = 0,cl_count = 0, idx, cl_line[act_cols * act_rows];
	memset(&cl_line[0], 0, (act_cols * act_rows));
	//action_flag = START;
	if((image_order.ImgOrder[0].BBType == BORDER) && (image_order.ImgOrder[0].FileID == 1))
	{
		memcpy(&cl_line[0],(uint32_t *)(extra_config.ExtraConfig1.FlStartAdr +(line_count1*extra_config.ExtraConfig1.BytesPerRow)), extra_config.ExtraConfig1.BytesPerRow);

		switch(body_count)
		{
			case 1: if(itr2 < image_order.ImgOrder[1].Iteration)
					{
						memcpy(&cl_line[extra_config.ExtraConfig1.BytesPerRow],(uint32_t *)(extra_config.ExtraConfig2.FlStartAdr +(line_count2*extra_config.ExtraConfig2.BytesPerRow)), extra_config.ExtraConfig2.BytesPerRow);
						line_count2++;
					}

					if(line_count1 == extra_config.ExtraConfig1.Height)
					{
						line_count1 = 0;
						itr1++;
					}
					if(line_count2 == extra_config.ExtraConfig2.Height)
					{
						line_count2 = 0;
						itr2++;
					}
			break;

			case 2: if(itr2 < image_order.ImgOrder[1].Iteration)
					{
						memcpy(&cl_line[extra_config.ExtraConfig1.BytesPerRow],(uint32_t *)(extra_config.ExtraConfig2.FlStartAdr +(line_count2*extra_config.ExtraConfig2.BytesPerRow)), extra_config.ExtraConfig2.BytesPerRow);
						line_count2++;
					}
					else if (itr3 < image_order.ImgOrder[2].Iteration)
					{
						memcpy(&cl_line[extra_config.ExtraConfig1.BytesPerRow],(uint32_t *)(extra_config.ExtraConfig3.FlStartAdr +(line_count3*extra_config.ExtraConfig3.BytesPerRow)), extra_config.ExtraConfig3.BytesPerRow);
						line_count3++;
					}

					if(line_count1 == extra_config.ExtraConfig1.Height)
					{
						line_count1 = 0;
						itr1++;
					}
					if(line_count2 == extra_config.ExtraConfig2.Height)
					{
						line_count2 = 0;
						itr2++;
					}
					if(line_count3 == extra_config.ExtraConfig3.Height)
					{
						line_count3 = 0;
						itr3++;
					}
			break;
			default: break;
		}
		line_count1++;

		GPIO_ResetBits(GPIOA, OE_PIN);

			for (addr = 0; addr < config_hw.MaxColumns; addr++)
			{
				if(config_hw.ActiveColumns[config_data.LogicColumns[addr]])
				{
					latch_addr_byte(config_data.LogicColumns[addr]);
					GPIO_SetBits(GPIOA, OE_PIN);
					cl_count = 0;
					for (cl_cards = 0; cl_cards < config_hw.MaxRows; cl_cards++)
					{
						if(config_hw.ActiveRows[cl_cards])
						{
							//idx = (idx_count * config_hw.MaxRows) + cl_cards;
							idx = (idx_count * act_rows) + cl_count;
							latch_data_byte(cl_line[idx]);
						}
						else
						{
							latch_data_byte(0x00);
						}
						cl_count++;
					}
					idx_count++;
					GPIO_ResetBits(GPIOA, OE_PIN);
				}
				else
				{
					latch_addr_byte(config_data.LogicColumns[addr]);
					GPIO_SetBits(GPIOA, OE_PIN);
					for (cl_cards = 0; cl_cards < config_hw.MaxRows; cl_cards++)
					{
						latch_data_byte(0x00);
					}
					GPIO_ResetBits(GPIOA, OE_PIN);
				}

			}
			feed_next_data = 0;
			g_curr_line++;
			currline_response(SUCCES);
			action_flag = IDLE;

	}
}
#endif

void fill_column(uint8_t *arr)
{
	int16_t iter = 0;

	for(iter = 0; iter < 16; iter++)
	{
		arr[iter] = iter;
	}
}
void action_test_pattern(void)
{
	uint8_t act_count;

	if(cmd_count >= (sizeof(ejac_cmd_test_pattern_t)+SIZE_CMD))
	{
		fill_column(config_data.LogicColumns);
		memcpy(&test_pattern, (save_buffer + SIZE_CMD), sizeof(ejac_cmd_test_pattern_t));
		line_count1 = 0;
		itr1 = 0;
		line_count2 = -1;
		itr2 = 0;
		/*line_count3 = -1;
		itr3 = 0;
		line_count4 = -1;
		itr4 = 0;*/
		g_curr_line = 0;


		//if(flash_start_addr[0] == 0)
		if(hrdwrSettingsDone == 0)
		{
			memcpy(&config_hw, (uint32_t *)0x0800C000, (SIZE_CMD_HW_CONFIG-SIZE_CMD));

			if(config_hw.Sensor1.Sensor_Status == EJAC_ENABLE)
			{
				if(config_hw.Sensor1.Sensor_Type == NPN)
				{
					sensor1_npn_init();
				}
				else if(config_hw.Sensor1.Sensor_Type == PNP)
				{
					sensor1_pnp_init();
				}
			}
			else
			{
				//sensor1_npn_init();
				//TODO:
				EXTI_ClearITPendingBit(EXTI_Line0);
				NVIC_DisableIRQ(EXTI0_IRQn);
			}

			if(config_hw.Sensor2.Sensor_Status == EJAC_ENABLE)
			{
				if(config_hw.Sensor2.Sensor_Type == NPN)
				{
					sensor2_npn_init();
				}
				else if(config_hw.Sensor2.Sensor_Type == PNP)
				{
					sensor2_pnp_init();
				}
			}
			else
			{
				//sensor2_npn_init();
				//TODO:
				EXTI_ClearITPendingBit(EXTI_Line1);
				NVIC_DisableIRQ(EXTI1_IRQn);
			}
			/*if(config_hw.Sensor3.Sensor_Status == EJAC_ENABLE)
			{
				if(config_hw.Sensor3.Sensor_Type == NPN)
				{
					sensor3_npn_init();
				}
				else if(config_hw.Sensor3.Sensor_Type == PNP)
				{
					sensor3_pnp_init();
				}
			}*/

			for(act_count = 0; act_count < config_hw.MaxRows; act_count++)
			{
				if(config_hw.ActiveRows[act_count])
				{
					act_rows++;
				}
			}
			for(act_count = 0; act_count < config_hw.MaxColumns; act_count++)
			{
				if(config_hw.ActiveColumns[act_count])
				{
					act_cols++;
				}
			}
		}

		//feed_next_data = 1;
		action_flag = IDLE;
		LatchingDataFlag = 0x01;
		action_feed_data();
		response(SUCCES);
		uint32_t i,j;
		hrdwrSettingsDone = 1;

		for(i =0; i<100;i++)
		{
			for(j =0; j<10000;j++);

		}

		if(config_hw.Sensor1.Sensor_Status == EJAC_ENABLE)
		{
			EXTI_ClearITPendingBit(EXTI_Line0);
			NVIC_EnableIRQ(EXTI0_IRQn);
		}
		if(config_hw.Sensor2.Sensor_Status == EJAC_ENABLE)
		{
			EXTI_ClearITPendingBit(EXTI_Line1);
			NVIC_EnableIRQ(EXTI1_IRQn);
		}
		cmd_count = 0;
	}
}
